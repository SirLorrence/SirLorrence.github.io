<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>AI Position System Prototype | Laurence Sadler</title>
<meta name="keywords" content="C#, Unity, AI, Prototype">
<meta name="description" content="I developed a flexible enemy positioning AI, using a custom query system.">
<meta name="author" content="">
<link rel="canonical" href="https://SirLorrence.github.io/projects/positioning-system-prototype/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.52e33300358c98501a2416ecbb40137de1801d2c850f0646f9913dde8162339f.css" integrity="sha256-UuMzADWMmFAaJBbsu0ATfeGAHSyFDwZG&#43;ZE93oFiM58=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://SirLorrence.github.io/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://SirLorrence.github.io/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://SirLorrence.github.io/assets/favicon-32x32.png%3E">
<link rel="apple-touch-icon" href="https://SirLorrence.github.io/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://SirLorrence.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://SirLorrence.github.io/projects/positioning-system-prototype/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="AI Position System Prototype" />
<meta property="og:description" content="I developed a flexible enemy positioning AI, using a custom query system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://SirLorrence.github.io/projects/positioning-system-prototype/" />
<meta property="og:image" content="https://github.com/SirLorrence/ReadMeImages/blob/main/AI-PositionSystem-Prototype/All-together-gif.gif?raw=true" /><meta property="article:section" content="projects" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://github.com/SirLorrence/ReadMeImages/blob/main/AI-PositionSystem-Prototype/All-together-gif.gif?raw=true" />
<meta name="twitter:title" content="AI Position System Prototype"/>
<meta name="twitter:description" content="I developed a flexible enemy positioning AI, using a custom query system."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Projects",
      "item": "https://SirLorrence.github.io/projects/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "AI Position System Prototype",
      "item": "https://SirLorrence.github.io/projects/positioning-system-prototype/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AI Position System Prototype",
  "name": "AI Position System Prototype",
  "description": "I developed a flexible enemy positioning AI, using a custom query system.",
  "keywords": [
    "C#", "Unity", "AI", "Prototype"
  ],
  "articleBody": "Project Summary In this project, I developed my own pseudo-environment query system. Initially, I was working on a top-down roguelike game. I wanted to improve how enemies move toward the player instead of just setting their move position to the player’s position. This process taught me a new approach to programming and thinking about AI movement.\nEngine: Unity\nLanguage: C#\nProject Repository Overview I came across an article called “Implementing Robust AI for SecondHand: Enemy Positioning” and then worked off its fundamental ideal. After some time and code experimenting, I wrapped my head around it and connected it to how Unreals EQS worked and from a Ubisoft GDC talk. Then, I broke down the workflow.\nCreating the Positions The development process started with creating the ‘PositioningPoint’ struct, which was responsible for managing the position and status of each point. These points were initially spawned around the target, which, in this case, was the player. It was crucial to keep track of and update each point’s position.\nExample of the Position Point Initialization:\nprivate PositioningPoint[] InitializePoints() { // Using a Dynamic Array during the creation of the positions then using a static(sized) array List initialSetPosition = new List(); //starting from 1 so the first ring doesn't spawn into the player for (int i = 1; i \u003c= rings; i++) { _positions = _initialPositions * i; for (int j = 0; j \u003c _positions; j++) { float radians = 2 * Mathf.PI / _positions * j; Vector3 newPoint = new Vector3(Mathf.Sin(radians), 0, Mathf.Cos(radians)); float ringSpacing = i + _radiusSpacing; Vector3 creationPoint = (newPoint * ringSpacing) + _target.position; Vector3 vecAwayFromTarget = creationPoint - _target.position; PositioningPoint point = new PositioningPoint { CurrentPos = creationPoint, OffsetPos = vecAwayFromTarget, AssignedStatus = false }; initialSetPosition.Add(point); } } return initialSetPosition.ToArray(); } Query Systems Then, I worked on the queries, starting with the Distance Query. This was relatively easy since all I needed to do was get the distance of each point to the player and rank based on the desired range specified by the AI. By default, the closer the point is to the target, the higher the score—this can be modified from a (float)slider that a designer or, in this case, myself can easily change and test different behaviors.\nprivate float[] DistanceFromTarget() { if (_posManager == null) return null; // calculate the distance from each point float[] distArray = new float[_posManager.Points.Length]; for (int i = 0; i \u003c _pointDataSize; i++) { distArray[i] = Vector3.Distance(_target.position, _posManager.Points[i].CurrentPos); } // Normalize each point between the min and max desired points float[] normalizedArray = new float[distArray.Length]; float min = distArray[0]; float max = distArray[distArray.GetUpperBound(0)]; min += preferredDist * (_posManager.Rings - 1); max += preferredDist * (_posManager.Rings - 1); for (int i = 0; i \u003c _pointDataSize; i++) { var nDistance = 1 - Mathf.Abs((distArray[i] - min) / (max - min)); nDistance = Mathf.Clamp01(nDistance); normalizedArray[i] = nDistance; } return normalizedArray; } After that, I worked on the Desired Angle of Approach Query. This was a bit tricky. I needed to get the Dot Product from each point and create a score based on that. It sounds easy when I explain it in a high-level way, but the issue came down to world coordinates. Depending on which quadrant the player or the AI is in, the angle calculation would completely flip—acting as if the AI is coming from a different direction. To get around this, I manually calculated the X and Z distance of the target and the player, then the target and the point, and then used to return the dot product of those (2d)vectors.\nprivate float[] AnglePreferenceForTarget(bool inverse = false) { if (_posManager == null) return null; Vector2 pointA = new Vector2(_target.position.x - transform.position.x, _target.position.z - transform.position.z); float[] tempArray = new float[_pointDataSize]; for (int i = 0; i \u003c _pointDataSize; i++) { var p = _posManager.Points[i].CurrentPos; Vector2 pointB = new Vector2(_target.position.x - p.x, _target.position.z - p.z); tempArray[i] = (Vector2.Dot(pointA.normalized, pointB.normalized) * ((inverse) ? -1 : 1)) + angleTolerance; } return tempArray; } Finally, I need to get the results from the queries. At first, I was stumped; my approach was doing method calculations simultaneously on each point. The logistics and the performance of it didn’t make much sense doing it that way. Then it started to click when fixing bugs on the angle query. Related side tangent: In one of the projects at work (Intel/UST), I was assigned a task to get a game engine working with Machine Learning, so I learned about a basic concept of ML called “Reinforcement Learning.” The essential idea is that the model tries a bunch of different tasks/behaviors, and based on the cycle’s outcome, it’s either rewarded or penalized - the following cycle, it will make changes based on the score it received. This cycle will repeat until it reaches its goal (ML people don’t crucify me; I didn’t dive that deep). So, coming back, I applied that concept to this problem. Each query returns an array of normalized scores between 0f and 1f, then each query array is added together, creating an ‘Uber Score’ array, and then the height position is selected. This worked (…well, with a few issues I needed to fix), and later added the ability to change the Influence/prioritize of the queries.\npublic void Evaluate() { if (!m_initFlag) { InitializeVariables(); } ResetScores(); AddScores(DistanceFromTarget(), enableDistanceParam, m_distanceQueryInfluence); AddScores(AnglePreferenceForTarget(invertDirection), enableFacingDirectionParam, m_angleQueryInfluence); _positionScores = _positionScores.Select(x =\u003e (float)Math.Round(x, 2)).ToArray(); int incomingPositionIndex = HighestWeight(); if (_positionScores[incomingPositionIndex] \u003e _positionScores[m_currentPositionIndex] || m_reposition) { SetPositionLocation(incomingPositionIndex); } } Take Aways Working on the project and learning how others implemented it, mine is a very simplified version, though most core concepts are the same. My version can be expanded further, and I’m glad I’ve coded it so you can create another query behavior and easily plug it in. I found how Ubisoft did it in the Division interesting because they baked the position points into the map data, and the complexity of their NPC systems is impressive.\n",
  "wordCount" : "985",
  "inLanguage": "en",
  "image":"https://github.com/SirLorrence/ReadMeImages/blob/main/AI-PositionSystem-Prototype/All-together-gif.gif?raw=true","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://SirLorrence.github.io/projects/positioning-system-prototype/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Laurence Sadler",
    "logo": {
      "@type": "ImageObject",
      "url": "https://SirLorrence.github.io/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://SirLorrence.github.io/" accesskey="h" title="Laurence Sadler (Alt + H)">Laurence Sadler</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://SirLorrence.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://SirLorrence.github.io/posts/" title="Blogs">
                    <span>Blogs</span>
                </a>
            </li>
            <li>
                <a href="https://SirLorrence.github.io/laurence_sadler-cv.pdf" title="CV">
                    <span>CV</span>
                </a>
            </li>
            <li>
                <a href="https://SirLorrence.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://SirLorrence.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://SirLorrence.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://SirLorrence.github.io/projects/">Projects</a></div>
    <h1 class="post-title entry-hint-parent">
      AI Position System Prototype
    </h1>
    <div class="post-meta"><a href="/tags/c"> C#</a>&nbsp;·&nbsp;<a href="/tags/unity"> Unity</a>&nbsp;·&nbsp;<a href="/tags/ai"> AI</a>&nbsp;·&nbsp;<a href="/tags/prototype"> Prototype</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://github.com/SirLorrence/ReadMeImages/blob/main/AI-PositionSystem-Prototype/All-together-gif.gif?raw=true" alt="">
        <p><!-- raw HTML omitted -->
</p>
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#project-summary" aria-label="Project Summary">Project Summary</a><ul>
                        
                <li>
                    <a href="#project-repositoryhttpsgithubcomsirlorrenceai-positionsystem-prototype" aria-label="Project Repository">Project Repository</a></li></ul>
                </li>
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a><ul>
                        
                <li>
                    <a href="#creating-the-positions" aria-label="Creating the Positions">Creating the Positions</a></li>
                <li>
                    <a href="#query-systems" aria-label="Query Systems">Query Systems</a></li>
                <li>
                    <a href="#take-aways" aria-label="Take Aways">Take Aways</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="project-summary">Project Summary<a hidden class="anchor" aria-hidden="true" href="#project-summary">#</a></h2>
<p>In this project, I developed my own pseudo-environment query system. Initially, I was working on a top-down roguelike game. I wanted to improve how enemies move toward the player instead of just setting their move position to the player&rsquo;s position. This process taught me a new approach to programming and thinking about AI movement.</p>
<p><strong>Engine:</strong> Unity</p>
<p><strong>Language:</strong> C#</p>
<h3 id="project-repositoryhttpsgithubcomsirlorrenceai-positionsystem-prototype"><strong><a href="https://github.com/SirLorrence/AI-PositionSystem-Prototype">Project Repository</a></strong><a hidden class="anchor" aria-hidden="true" href="#project-repositoryhttpsgithubcomsirlorrenceai-positionsystem-prototype">#</a></h3>
<hr>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>I came across an article called &ldquo;Implementing Robust AI for SecondHand: Enemy Positioning&rdquo; and then worked off its fundamental ideal. After some time and code experimenting, I wrapped my head around it and connected it to how Unreals EQS worked and from a Ubisoft GDC talk. Then, I broke down the workflow.</p>
<h3 id="creating-the-positions">Creating the Positions<a hidden class="anchor" aria-hidden="true" href="#creating-the-positions">#</a></h3>
<p>The development process started with creating the &lsquo;PositioningPoint&rsquo; struct, which was responsible for managing the position and status of each point. These points were initially spawned around the target, which, in this case, was the player. It was crucial to keep track of and update each point&rsquo;s position.</p>
<p>Example of the Position Point Initialization:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> PositioningPoint[] InitializePoints() {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Using a Dynamic Array during the creation of the positions then using a static(sized) array</span>
</span></span><span style="display:flex;"><span>   List&lt;PositioningPoint&gt; initialSetPosition = <span style="color:#66d9ef">new</span> List&lt;PositioningPoint&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//starting from 1 so the first ring doesn&#39;t spawn into the player</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">1</span>; i &lt;= rings; i++) {
</span></span><span style="display:flex;"><span>     _positions = _initialPositions * i;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j = <span style="color:#ae81ff">0</span>; j &lt; _positions; j++) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">float</span> radians = <span style="color:#ae81ff">2</span> * Mathf.PI / _positions * j;
</span></span><span style="display:flex;"><span>       Vector3 newPoint = <span style="color:#66d9ef">new</span> Vector3(Mathf.Sin(radians), <span style="color:#ae81ff">0</span>, Mathf.Cos(radians));
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">float</span> ringSpacing = i + _radiusSpacing;
</span></span><span style="display:flex;"><span>       Vector3 creationPoint = (newPoint * ringSpacing) + _target.position;
</span></span><span style="display:flex;"><span>       Vector3 vecAwayFromTarget = creationPoint - _target.position;
</span></span><span style="display:flex;"><span>       PositioningPoint point = <span style="color:#66d9ef">new</span> PositioningPoint {
</span></span><span style="display:flex;"><span>         CurrentPos = creationPoint,
</span></span><span style="display:flex;"><span>         OffsetPos = vecAwayFromTarget,
</span></span><span style="display:flex;"><span>         AssignedStatus = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>       };
</span></span><span style="display:flex;"><span>       initialSetPosition.Add(point);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> initialSetPosition.ToArray();
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><h3 id="query-systems">Query Systems<a hidden class="anchor" aria-hidden="true" href="#query-systems">#</a></h3>
<p>Then, I worked on the queries, starting with the Distance Query. This was relatively easy since all I needed to do was get the distance of each point to the player and rank based on the desired range specified by the AI. By default, the closer the point is to the target, the higher the score—this can be modified from a (float)slider that a designer or, in this case, myself can easily change and test different behaviors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">float</span>[] DistanceFromTarget() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (_posManager == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// calculate the distance from each point</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span>[] distArray = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>[_posManager.Points.Length];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _pointDataSize; i++) {
</span></span><span style="display:flex;"><span>    distArray[i] = Vector3.Distance(_target.position, _posManager.Points[i].CurrentPos);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Normalize each point between the min and max desired points</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span>[] normalizedArray = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>[distArray.Length];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span> min = distArray[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span> max = distArray[distArray.GetUpperBound(<span style="color:#ae81ff">0</span>)];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  min += preferredDist * (_posManager.Rings - <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  max += preferredDist * (_posManager.Rings - <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _pointDataSize; i++) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> nDistance = <span style="color:#ae81ff">1</span> - Mathf.Abs((distArray[i] - min) / (max - min));
</span></span><span style="display:flex;"><span>    nDistance = Mathf.Clamp01(nDistance);
</span></span><span style="display:flex;"><span>    normalizedArray[i] = nDistance;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> normalizedArray;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After that, I worked on the Desired Angle of Approach Query. This was a bit tricky. I needed to get the Dot Product from each point and create a score based on that. It sounds easy when I explain it in a high-level way, but the issue came down to world coordinates. Depending on which quadrant the player or the AI is in, the angle calculation would completely flip—acting as if the AI is coming from a different direction. To get around this, I manually calculated the X and Z distance of the target and the player, then the target and the point, and then used to return the dot product of those (2d)vectors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">float</span>[] AnglePreferenceForTarget(<span style="color:#66d9ef">bool</span> inverse = <span style="color:#66d9ef">false</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (_posManager == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  Vector2 pointA = <span style="color:#66d9ef">new</span> Vector2(_target.position.x - transform.position.x, _target.position.z - transform.position.z);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span>[] tempArray = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>[_pointDataSize];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _pointDataSize; i++) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> p = _posManager.Points[i].CurrentPos;
</span></span><span style="display:flex;"><span>    Vector2 pointB = <span style="color:#66d9ef">new</span> Vector2(_target.position.x - p.x, _target.position.z - p.z);
</span></span><span style="display:flex;"><span>    tempArray[i] = (Vector2.Dot(pointA.normalized, pointB.normalized) * ((inverse) ? -<span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">1</span>)) + angleTolerance;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> tempArray;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, I need to get the results from the queries. At first, I was stumped; my approach was doing method calculations simultaneously on each point. The logistics and the performance of it didn&rsquo;t make much sense doing it that way. Then it started to click when fixing bugs on the angle query. Related side tangent: In one of the projects at work (Intel/UST), I was assigned a task to get a game engine working with Machine Learning, so I learned about a basic concept of ML called &ldquo;Reinforcement Learning.&rdquo; The essential idea is that the model tries a bunch of different tasks/behaviors, and based on the cycle&rsquo;s outcome, it&rsquo;s either rewarded or penalized - the following cycle, it will make changes based on the score it received. This cycle will repeat until it reaches its goal (ML people don&rsquo;t crucify me; I didn&rsquo;t dive that deep). So, coming back, I applied that concept to this problem. Each query returns an array of normalized scores between 0f and 1f, then each query array is added together, creating an &lsquo;Uber Score&rsquo; array, and then the height position is selected. This worked (&hellip;well, with a few issues I needed to fix), and later added the ability to change the Influence/prioritize of the queries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Evaluate() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (!m_initFlag) {
</span></span><span style="display:flex;"><span>    InitializeVariables();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ResetScores();
</span></span><span style="display:flex;"><span>  AddScores(DistanceFromTarget(), enableDistanceParam, m_distanceQueryInfluence);
</span></span><span style="display:flex;"><span>  AddScores(AnglePreferenceForTarget(invertDirection), enableFacingDirectionParam, m_angleQueryInfluence);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  _positionScores = _positionScores.Select(x =&gt; (<span style="color:#66d9ef">float</span>)Math.Round(x, <span style="color:#ae81ff">2</span>)).ToArray();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> incomingPositionIndex = HighestWeight();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (_positionScores[incomingPositionIndex] &gt; _positionScores[m_currentPositionIndex] || m_reposition) {
</span></span><span style="display:flex;"><span>    SetPositionLocation(incomingPositionIndex);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="take-aways">Take Aways<a hidden class="anchor" aria-hidden="true" href="#take-aways">#</a></h3>
<p>Working on the project and learning how others implemented it, mine is a very simplified version, though most core concepts are the same. My version can be expanded further, and I&rsquo;m glad I&rsquo;ve coded it so you can create another query behavior and easily plug it in. I found how Ubisoft did it in the Division interesting because they baked the position points into the map data, and the complexity of their NPC systems is impressive.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://SirLorrence.github.io/tags/c%23/">C#</a></li>
      <li><a href="https://SirLorrence.github.io/tags/unity/">Unity</a></li>
      <li><a href="https://SirLorrence.github.io/tags/ai/">AI</a></li>
      <li><a href="https://SirLorrence.github.io/tags/prototype/">Prototype</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://SirLorrence.github.io/projects/ray-tracer/">
    <span class="title">Next »</span>
    <br>
    <span>Software Ray Tracer</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://SirLorrence.github.io/">Laurence Sadler</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
